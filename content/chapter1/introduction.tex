\section{Introduction} \label{sec:introduction} 

In the evolving landscape of software architecture, the software development paradigms of
\gls{ca} and \gls{ns} have emerged as pivotal in addressing the multifaceted challenges of
software design, particularly in managing stability, modularity, and evolvability to
achieve resiliency in software. This paper delves into the synergy between these two
paradigms, each contributing significantly to the contemporary discourse on software
architectural complexity.

Tracing the historical underpinnings of these concepts reveals the works of pioneers like
\textcite{d_mcilroy_nato_1968}, who championed modular programming, and
\textcite{lehman_programs_1980}, who underscored the importance of software evolution.
Contributions from \textcite{dijkstra_letters_1968} on structured programming and
\textcite{parnas_criteria_1972} on software modularity further cemented the foundation for
\gls{ca} and \gls{ns}. These historical insights contextualize the evolution of software
engineering principles and underscore the relevance of fostering maintainable and
evolvable software systems.

The foundation of this paper is an exploration of findings from extensive research on
the convergence of CA and NS \cite{koks_convergence_2023}. This research provides a
nuanced perspective on integrating these distinct yet harmonious frameworks to enhance
software design. It meticulously examines the core principles and elements of both
\gls{ca} and \gls{ns}, presenting a scientifically robust synthesis that addresses
critical challenges in software architecture.

This paper outlines the insights from the research conducted by
\citename{koks_convergence_2023}{author}, exploring the significant benefits and practical
implications of integrating the strengths of \gls{ca} and \gls{ns} within the dynamic
field of software development. 


The introduction is intended to set the stage and articulate the goal of this paper.
Section 2 lays out the theoretical background, zooming in on the specific principles and
elements of each Software Design Paradigm while also highlighting their unified concepts.
In Section 3, we analyze the similarities and differences of their principles and elements
and their effect on the evolvability of software constructs. The paper summarizes the
conclusions in Section 4.